I want to use client side sorting of profiles after loading them in within a certain distance. 
I feel like I've never actually seen that before for personality type at least.
Facebook has sort by children and so on, but no tags or personality types. 
Not having this would just be lazy after all the data has been loaded into your phone anyway. 

You should be able to sort by: 

distance
height
age

children 
personality type
looking for 
tags
lists

Tags:
drug status, work out frequency, sleep schedule, student status,

Lists:
liked, disliked, favs

NO
edu, smoking, drinking, religion 

for the grid view im officially copying iphone. Shouldnt take that much longer and it is the best
- require more screen per pinch input
- fading pictures
- animate to adjacent zoom level unless second zoom level threshold is reached 


===========
== TODO: ==
===========
- only cache images once when drop down button is pressed

- Cache images when a profile is opened in swipe view from the list / search bar

- remove background color from the top buttons row

- check list of cached profiles against list of firebase profiles. Ensure no duplicates 

- arange firebase profiles in order and then check against cache again

- Check for unecessary page rebuilds with Widget build() print statements
  e.g. print('Swipe page building now!');

- test loading, filtering, and sorting for profiles with empty data fields

- applyFilters is running twice every time... the only problem with that is it refreshes the screen multiple times. 

- list page and scroll state rebuild after the ring algo completes, it shouldn't until the user presses next page,
  unless it is the last page already 

===========
== BUGS: ==
===========
- too many builds when zooming out profiles too early 
- profile verification needs a look
- whole app needs a look

- shutting off the app mid query may break it
- the ring algo starts after initial load, and the next page buttonshould be loading until the initial ring query is complete. 

- after canceling the phone verif once, it no longer sends

- if initial query finds more than max profiles (210) in a hash of precision 6, it breaks

- if large initial hash exceeds firestore query limit, no query is made 

- After cacheing a large radius, the shortenRings function will know not to query any smaller radii, but this requires a moderate 
  ammount of calculations. It maybe easier to do this another way, but it only adds like .5 seconds of load time. 

- Make sure the ring algo picks up at the appropriate spot after the initial large hash query 

- The 5 mile radius is never cached after the initial ring algo. This loads in the first page after every filter 
  update 

- If rebuilt after the initial hash query and before the initial ring algo, the saveLastFirebaseProfile never runs and the ring algo ring shortener breaks. To fix consider fetching last profile from cache or just deleting cache and recaching profiles.

- If you log out while querying the app crashes because you need an authenticated user to query. 

- seems like deleting the account deletes the auth doc but does not delete the user doc, meaning a new account can not be created with the same phone number

- infinite initial hash tests when no users found

- add loading wheel when loading in initial profiles

- eliminate second page rebuild after finishing ring algo

- make profiles appear behind search bar in the banner view

- bottom of page message tells user to increase distance radius when the current distance has not been fully loaded

- after loading in ring algo profiels the page scroll position resets to the top

- on first download of app the notifications permission pop up does not display unless rebuilt. The app does not fetch profiles until the permissions are allowed

FATAL ERROR  FATAL ERROR  FATAL ERROR  FATAL ERROR  FATAL ERROR  FATAL ERROR  FATAL ERROR  FATAL ERROR  FATAL ERROR  
- on first query if there are over the maximum in a large hash and 0 in the hash smaller, none are loaded. 
FATAL ERROR  FATAL ERROR  FATAL ERROR  FATAL ERROR  FATAL ERROR  FATAL ERROR  FATAL ERROR  FATAL ERROR  FATAL ERROR  

=========================
== POTENTIAL PROBLEMS: ==
=========================

BEFORE (android/app/build.gradle.kts)

buildTypes {
  release {
    signingConfig = signingConfigs.getByName("debug")
  }
}

AFTER

buildTypes {
  getByName("release") {
    isMinifyEnabled = true // Kotlin Script syntax for minifyEnabled
    isShrinkResources = true // Kotlin Script syntax for shrinkResources
    proguardFiles(
        getDefaultProguardFile("proguard-android-optimize.txt"),
        "proguard-rules.pro"
    )
    signingConfig = signingConfigs.getByName("debug") // Use debug signing for testing    
  }
}

================
== CHECKLIST: ==
================

=====  
|   |  
=====

=====  Warning: The debug provider allows access to your Firebase resources from unverified
|   |  devices. Don't use the debug provider in production builds of your app, and don't share 
=====  your debug builds with untrusted parties.    

=====  check AndroidManifest.xml for unnecessary permisions 
|   |  
=====    

=====  privacy policy   
|   |  
=====

=====  out of country phone number support   
|   |  
=====

=====  android:networkSecurityConfig="@xml/network_security_config"    
|   |  delete this and the file it's for the firebase emulator
=====

=====  turn pc firewall back on
|   |  netsh advfirewall set allprofiles state off (turn on)
=====

=====  delete firebase.json  
|   |  
=====

=====  don't use mounted accross async scopes as this my crash the app. e.g. snackbar scaffolds   
|   |  from other files that display over the page refferencing the file
=====

=====  For cost control, you can set the maximum number of containers that can be
|   |  running at the same time. This helps mitigate the impact of unexpected
=====  traffic spikes by instead downgrading performance. This limit is a per-function
       limit. You can override the limit for each function using the max_instances
       parameter in the decorator, e.g. @https_fn.on_request(max_instances=5).

=====  warning: [options] To suppress warnings about obsolete options, use -Xlint:-options.
|   |  3 warnings
=====  warning: [options] source value 8 is obsolete and will be removed in a future release
       warning: [options] target value 8 is obsolete and will be removed in a future release
       warning: [options] To suppress warnings about obsolete options, use -Xlint:-options.
       3 warnings
       
       (upon app installation)

=====  is it dangerous to use ! for null checking? Will it crash my app and should is use an if 
|   |  null check instead?
=====

=====  So it seems that any compute heavy functino should be a Future to avoid crashing the UI 
|   |  thread during builds or usage
=====

=====  QUERY USR CURRENT HASH (see hash GeoViz without shortner it isn't in the first rings)  
|   |  
=====

=====  ctrl f: CHECK    
|   |  
=====

=====  does loadCachedOrFirebaseProfiles need to be async ?? and await called every instance ??  
|   |  
=====

=====  The initial hash may contain > 105, which is the limit for my initial firebase query   
|   |  
=====

=====  Every once in awhile the garbage collector (GC) starts and the app won't start until reinstalled  
|   |  
=====

=====  check for redundant profiles after getting initial hash and starting first ring  
|   |  
=====

=====  update C:\Users\esmed\Documents\code\flutter   
|   |  projects\integra_date\android\app\src\main\res\xml\network_security_config.xml
=====

=====  If the user moves 20 miles from the central location, the ring algo should   
|   |  restart from the new location. Right now the central location is updated without 
=====  triggering a restart.

=====  Change SHA key to prod in public/.well-known/assetlinks.json && wherever else  
|   |  
=====
C2:D3:CB:EF:01:35:FD:1B:8C:76:7F:D6:E5:20:77:EC:E8:2E:BB:96:BF:21:5E:D0:A6:10:51:E8:07:55:5D:8A

==========================
== FUTURE OPTIMIZATION: ==
==========================

- there doesn't need to be a new list of saved, liked, and disliked profiles. Instead, toggle a saved, liked, or disliked tag in the existing users table to use for filtering and UI indicators. Currently a whole new list is created which uses more space and requires more indexing.   